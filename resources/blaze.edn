{:base-config
 {:blaze.terminology-service/extern
  {:uri #blaze/cfg ["TERM_SERVICE_URI" string? "http://tx.fhir.org/r4"]
   :proxy-host #blaze/cfg ["PROXY_HOST" string?]
   :proxy-port #blaze/cfg ["PROXY_PORT" pos-int?]
   :proxy-user #blaze/cfg ["PROXY_USER" string?]
   :proxy-password #blaze/cfg ["PROXY_PASSWORD" string?]
   :connection-timeout #blaze/cfg ["CONNECTION_TIMEOUT" pos-int?]
   :request-timeout #blaze/cfg ["REQUEST_TIMEOUT" pos-int?]}

  :blaze.terminology-service.extern/errors-total {}
  :blaze.terminology-service.extern/request-duration-seconds {}

  :blaze.interaction.history/system
  {:database/conn #blaze/ref :blaze.datomic/conn}

  :blaze.interaction.history/type
  {:database/conn #blaze/ref :blaze.datomic/conn}

  :blaze.interaction.history/instance
  {:database/conn #blaze/ref :blaze.datomic/conn}

  :blaze.interaction/create
  {:database/transaction-executor #blaze/ref :blaze.datomic.transaction/executor
   :database/conn #blaze/ref :blaze.datomic/conn
   :term-service #blaze/ref :blaze/terminology-service}

  :blaze.interaction/delete
  {:database/transaction-executor #blaze/ref :blaze.datomic.transaction/executor
   :database/conn #blaze/ref :blaze.datomic/conn}

  :blaze.interaction/read
  {:database/conn #blaze/ref :blaze.datomic/conn}

  [:blaze.interaction/search-type :blaze.interaction.search/default]
  {:database/conn #blaze/ref :blaze.datomic/conn}

  :blaze.interaction.transaction/executor {}

  :blaze.interaction.transaction/handler
  {:database/transaction-executor #blaze/ref :blaze.datomic.transaction/executor
   :database/conn #blaze/ref :blaze.datomic/conn
   :term-service #blaze/ref :blaze/terminology-service
   :executor #blaze/ref :blaze.interaction.transaction/executor}

  :blaze.interaction/update
  {:database/transaction-executor #blaze/ref :blaze.datomic.transaction/executor
   :database/conn #blaze/ref :blaze.datomic/conn
   :term-service #blaze/ref :blaze/terminology-service}

  :blaze.fhir.operation.evaluate-measure/executor {}

  :blaze.fhir.operation.evaluate-measure/handler
  {:clock #blaze/ref :blaze/clock
   :database/transaction-executor #blaze/ref :blaze.datomic.transaction/executor
   :database/conn #blaze/ref :blaze.datomic/conn
   :term-service #blaze/ref :blaze/terminology-service
   :executor #blaze/ref :blaze.fhir.operation.evaluate-measure/executor}

  :blaze.fhir.operation.evaluate-measure/compile-duration-seconds {}
  :blaze.fhir.operation.evaluate-measure/evaluate-duration-seconds {}

  :blaze/rest-api
  {:transaction-handler #blaze/ref :blaze.interaction.transaction/handler
   :history-system-handler #blaze/ref :blaze.interaction.history/system
   :resource-patterns
   [#:blaze.rest-api.resource-pattern
    {:type :default
     :interactions
     {:read
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/read}
      :vread
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/read}
      :update
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/update}
      :delete
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/delete}
      :history-instance
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction.history/instance}
      :history-type
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction.history/type}
      :create
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/create}
      :search-type
      #:blaze.rest-api.interaction
      {:handler #blaze/ref [:blaze.interaction/search-type :blaze.interaction.search/default]}}}
    ;; breeze api
    #:blaze.rest-api.resource-pattern
    {:type "Condition"
     :interactions
     {:search-type
      #:blaze.rest-api.interaction
      {:handler #blaze/ref [:blaze.interaction/search-type :blaze.interaction.search/Condition]}
      :read
      #:blaze.rest-api.interaction
      {:handler #blaze/ref :blaze.interaction/read}}}]
   :operations
   [#:blaze.rest-api.operation
    {:code "evaluate-measure"
     :def-uri "http://hl7.org/fhir/OperationDefinition/Measure-evaluate-measure"
     :resource-types ["Measure"]
     :type-handler #blaze/ref :blaze.fhir.operation.evaluate-measure/handler
     :instance-handler #blaze/ref :blaze.fhir.operation.evaluate-measure/handler}]}

  ;; TODO: May want to add a new key that specifies the mapping between fhir and our datomic schema
  ;; It should be a ref that points to another part of this edn file with the (data) description of the mapping
  ;; Try to make it so Alex will like it. We will want our mapping descriptions to happen previously,
  ;; Alex probably prefers them to happen in real time. The difference is we want to point to some data,
  ;; he will probably want to point to a function that transforms the fhir json files during startup
  ;; would be nice to be able to handle 2 versions at the same time for a given resource. Probably the simplest way to do this is to
  ;; point to a ref where that ref may be a function that resolves the mapping or already raw mapping
  ;;
  ;; the search parameters are incomplete
  ;; consider the invariants https://www.hl7.org/fhir/condition.html#invs
  ;; consider using clojure spec, don't try to prevent all possible errors. use it for information, mainly as documentation,
  ;;  can also use to generate things (docs?) that make sense
  ;; we'll need to be able to reference custom functions as well (like handle the merging of identifier and identifier$id)
  ;; later we'll need to optimize the searching handler but not yet
  ;;
  ;; get to a concrete implementation fairly quickly. focus on condition and have it work on our database
  ;; don't do edn generation, manually edit it
  ;; do modify the interaction module handlers
  ;; writing is a lower priority. All Drew needs is reading and searching

  [:blaze.interaction/search-type :blaze.interaction.search/Condition]
  {:database/conn                     #blaze/ref :blaze.datomic/conn
   :schema/pattern                    #blaze/ref [:blaze.schema/pattern :blaze.interaction.search/Condition]
   :schema/mapping                    #blaze/ref [:blaze.schema/mapping :blaze.interaction.search/Condition]
   :blaze.fhir.SearchParameter/config [{:blaze.fhir.SearchParameter/code       "patient"
                                        :blaze.fhir.SearchParameter/expression [:Condition/subject :Patient/id]}
                                       {:blaze.fhir.SearchParameter/code       "category"
                                        :blaze.fhir.SearchParameter/expression [:Condition/category :CodeableConcept/coding :Coding/code :code/code]}]}

  [:blaze.schema/mapping :blaze.interaction.search/Condition]
  {:fn      nil
   :mapping {;; Generic
             :phi.element/type               {:key   nil
                                              :value nil}
             :fhir.CodeableConcept/coding$cr {:key   :fhir.CodeableConcept/coding
                                              :value blaze.fhir.transforms/coding}
             ;; TODO: I can actually probably just use generic :fhir.Resource/id because I need to update the
             ;; pull expression to get the phi.element/type which will dictate the reference prefix
             ;; Condition specific
             :fhir.v3.Condition/subject      {:key   :fhir.v3.Condition/subject
                                              :value blaze.fhir.transforms/reference}}}

  [:blaze.schema/pattern :blaze.interaction.search/Condition]
  {:fn      nil
   :pattern [:fhir.Resource/id
             :phi.element/type
             :fhir.v3.Condition/abatementAge
             :fhir.v3.Condition/abatementBoolean
             :fhir.v3.Condition/abatementDateTime
             :fhir.v3.Condition/abatementPeriod
             :fhir.v3.Condition/abatementRange
             :fhir.v3.Condition/abatementString
             :fhir.v3.Condition/assertedDate
             {:fhir.v3.Condition/asserter [:fhir.Resource/id]}
             :fhir.v3.Condition/bodySite
             :fhir.v3.Condition/category
             :fhir.v3.Condition/clinicalStatus
             :fhir.v3.Condition/code
             {:fhir.v3.Condition/context [:fhir.Resource/id]}
             :fhir.v3.Condition/evidence
             :fhir.v3.Condition/identifier
             :fhir.v3.Condition/note
             :fhir.v3.Condition/onsetAge
             :fhir.v3.Condition/onsetDateTime
             :fhir.v3.Condition/onsetPeriod
             :fhir.v3.Condition/onsetRange
             :fhir.v3.Condition/onsetString
             :fhir.v3.Condition/severity
             :fhir.v3.Condition/stage
             {:fhir.v3.Condition/subject [:fhir.Resource/id]}
             :fhir.v3.Condition/verificationStatus
             :fhir.v3.Condition.evidence/code
             :fhir.v3.Condition.evidence/detail
             :fhir.v3.Condition.stage/assessment
             :fhir.v3.Condition.stage/summary]}

  }

 :features
 [{:name "OpenID Authentication"
   :toggle "OPENID_PROVIDER_URL"
   :config
   {[:blaze.auth/backend :blaze.openid-auth/backend]
    {:openid-provider/url #blaze/cfg ["OPENID_PROVIDER_URL" string?]}}}]}
